Index: app/course.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import string\r\n\r\n\r\nclass Course:\r\n    name: string\r\n    id: string\r\n    day: list\r\n    begin_time: list\r\n    end_time: list\r\n    week: list\r\n    offline: bool\r\n    student: list\r\n\r\n    # id:,name:\r\n    def __init__(self, name, day, begin_time, end_time, week, offline, student):\r\n        self.name: string = name\r\n        self.day = [int(x) for x in day]\r\n        begin_hour = int(begin_time[:2])\r\n        begin_minute = int(begin_time[3:])\r\n        self.begin_time: list = [begin_hour, begin_minute]\r\n        end_hour = int(end_time[:2])\r\n        end_minute = int(end_time[3:])\r\n        self.end_time: list = [end_hour, end_minute]\r\n        self.week: list = [int(x) for x in week]\r\n        if offline == 1:\r\n            self.offline: bool = True\r\n        else:\r\n            self.offline: bool = False\r\n        self.student = [int(x) for x in student]\r\n\r\n    \"\"\"def __init__(self, name, student):\r\n        self.name: string = name\r\n        self.id: string\r\n        self.begin_time: int\r\n        self.end_time: int\r\n        self.week: list = []\r\n        self.offline: bool\r\n        self.student = student\"\"\"\r\n\r\n\r\nclass MyHash:\r\n    my_hash_table: list = []\r\n    empty: list = []\r\n\r\n    def __init__(self):\r\n        self.my_hash_table: list = []\r\n        self.empty: list = []\r\n\r\n    def insert(self, value):\r\n        # 如果列表中有空值,则插入该节点，如果没有，则插入末尾\r\n        if self.empty:\r\n            hash_id = self.empty[-1]\r\n        else:\r\n            hash_id = len(self.my_hash_table)\r\n        self.my_hash_table.insert(hash_id, value)\r\n        value.id = hash_id\r\n\r\n    def find(self, hash_id):\r\n        if hash_id < len(self.my_hash_table):\r\n            return self.my_hash_table[hash_id]\r\n        else:\r\n            return None\r\n\r\n    def remove(self, hash_id):\r\n        if hash_id < len(self.my_hash_table):\r\n            self.my_hash_table[hash_id] = None\r\n        else:\r\n            print(\"hash 删除错误\")\r\n\r\n    def revise(self, old_course, new_course):\r\n        if self.find(old_course) is not None:\r\n            self.remove(old_course.id)\r\n            self.insert(new_course)\r\n\r\n    def empty(self):\r\n        if len(self.my_hash_table) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\nclass BPlusNode:\r\n    is_leaf: bool  #\r\n    keys: list  # 保存键\r\n    values: list  # 保存值\r\n    next: list  # 如果不是叶子节点next保存下一层节点，否则保存后续节点\r\n\r\n    def __init__(self, is_leaf=False):\r\n        self.is_leaf: bool = is_leaf\r\n        self.keys = []\r\n        self.values = []\r\n        self.next = []  # 如果不是叶子节点next保存下一层节点，否则保存后续节点\r\n\r\n    # 寻找key的索引，如果不是叶子节点，则返回下一层的节点，如果是叶子节点，则返回key的下标\r\n    def find_index(self, key):\r\n        left = 0\r\n        right = len(self.keys) - 1\r\n        while left <= right:\r\n            mid = (right + left) // 2\r\n            if self.keys[mid] == key:\r\n                return mid\r\n            elif self.keys[mid] > key:\r\n                right = mid - 1\r\n            else:\r\n                left = mid + 1\r\n        return left\r\n\r\n    # 每个索引节点数据量较小使用顺序查找\r\n    def find_next_index(self, key):\r\n        for index in range(0, len(self.keys)):\r\n            if key < self.keys[index]:\r\n                # print(f\"{key}<{self.keys[index]}\")\r\n                return index\r\n        return len(self.keys)\r\n\r\n    # 寻找key的值\r\n    def find_value(self, key):\r\n        index = self.find_index(key)\r\n        \"\"\"如果self.keys的长度不为0则说明，那么self是叶子节点，\r\n           因为find_next_index中如果没有查询到对应的值，返回的是下一层的节点，这样在叶子节点中会返回错误的下标\r\n           所以要检查查询到的值与key是否一样，如果一样返回对应的值，不一样则返回None\"\"\"\r\n        if self.is_leaf and self.keys[index] == key:\r\n            # print(f\"key:{key},index:{index},keys:{self.keys}\")\r\n            # print(f\"values[{index}].id:{self.values[index].id}\")\r\n            return self.values[index]\r\n        elif self.is_leaf:\r\n            return None\r\n        else:\r\n            next_index = self.find_next_index(key)\r\n            # print(f\"key:{key},next_index:{next_index},keys:{self.keys}\")\r\n            # print(f\"next[{next_index}].keys:{self.next[next_index].keys}\")\r\n            return self.next[next_index].find_value(key)\r\n\r\n    def find_prefix_value(self, key):\r\n        index = self.find_index(key)\r\n        # print(f\"self.keys:{self.keys}\")\r\n        \"\"\"如果self.keys的长度不为0则说明，那么self是叶子节点，\r\n           因为find_next_index中如果没有查询到对应的值，返回的是下一层的节点，这样在叶子节点中会返回错误的下标\r\n           所以要检查查询到的值与key是否一样，如果一样返回对应的值，不一样则返回None\"\"\"\r\n        if self.is_leaf and self.keys[index] == key:\r\n            value: list = []\r\n            print(\"leaf\")\r\n            print(f\"self.keys:{self.keys}\")\r\n            while index < len(self.keys):\r\n                if key in self.keys[index]:\r\n                    value.append(self.values[index])\r\n                    index = index + 1\r\n                else:\r\n                    return value\r\n            node = self\r\n            while True:\r\n                index = 0\r\n                node = node.next[0]\r\n                while index < len(node.keys):\r\n                    if key in node.keys[index]:\r\n                        value.append(node.values[index])\r\n                        index = index + 1\r\n                    else:\r\n                        return value\r\n        elif self.is_leaf:\r\n            print(\"leaf\")\r\n            print(f\"self.keys:{self.keys}\")\r\n            return None\r\n        else:\r\n\r\n            next_index = self.find_next_index(key)\r\n            return self.next[next_index].find_prefix_value(key)\r\n\r\n    # 递归插入\r\n    \"\"\"如果不是叶子节点则继续深入，否则添加元素。如果添加了元素，则要检查是否超过了树的阶，如果超过了则要分裂产生兄弟节点并将兄弟节点返回\r\n        这里设置了一个全局变量carry来保存要添加到父节点的索引。\"\"\"\r\n\r\n    def insert(self, key, value):\r\n        global carry\r\n        # 先找到要插入的位置\r\n        if self.is_leaf is False:\r\n            # print(f\"key:{key}    next_index:{self.find_next_index(key)}\")\r\n            # 如果不是叶子节点则递归深入\r\n            new_node = self.next[self.find_next_index(key)].insert(key, value)\r\n            # 如果有来自子节点的索引要添加到这一层\r\n            if new_node is not None:\r\n                key = carry\r\n                # 要添加的位置\r\n                index = self.find_index(key)\r\n                self.keys.insert(index, key)\r\n                # print(key)\r\n                next_index = self.find_next_index(key)\r\n                # print(f\"new_node.keys[0]={carry}\")\r\n                # print(f\"len:{len(self.next)},next_index:{next_index}\")\r\n                # 如果下一层添加了新的节点，则把子节点添加到上一层的next中\r\n                self.next.insert(next_index, new_node)\r\n            else:\r\n                index = None\r\n        else:\r\n            # print(f\"key:{key}    index:{self.find_index(key)}\")\r\n            index = self.find_index(key)\r\n            self.keys.insert(index, key)\r\n            self.values.insert(index, value)\r\n        # 插入\r\n        if index is not None:\r\n            # 如果超过最大长度，则添加兄弟节点\r\n            if len(self.keys) > BPlusTree.max_keys:\r\n                sibling = BPlusNode(is_leaf=self.is_leaf)\r\n                # print(f\"len:{len(self.next)}\")\r\n                mid_index = len(self.keys) // 2\r\n                # 保存要添加到父亲节点上的索引\r\n                carry = self.keys[mid_index]\r\n                # 如果是叶子节点则next保存兄弟节点\r\n                if self.is_leaf:\r\n                    sibling.next = self.next\r\n                    self.next = [sibling]\r\n                    sibling.keys = self.keys[mid_index:]\r\n                    self.keys = self.keys[:mid_index]\r\n                    sibling.values = self.values[mid_index:]\r\n                    self.values = self.values[:mid_index]\r\n                    # print(f\"len:{len(self.next)}\")\r\n                # 如果不是叶子节点则保存下一层的节点\r\n                else:\r\n                    mid_next_index = len(self.next) // 2\r\n                    sibling.keys = self.keys[mid_index + 1:]\r\n                    self.keys = self.keys[:mid_index]\r\n                    sibling.next = self.next[mid_next_index:]\r\n                    self.next = self.next[:mid_next_index]\r\n                    # print(f\"mid={mid_index}len:{len(self.next)}\")\r\n                # 返回新节点\r\n                return sibling\r\n            else:\r\n                return None\r\n\r\n    \"\"\"判断要向哪个节点合并或借元素\"\"\"\r\n\r\n    def find_merge_index(self, parent):\r\n        self_index = parent.next.index(self)\r\n        # print(f\"self_index:{self_index} len(parent.next):{len(parent.next)} parent.keys:{parent.keys}\")\r\n        # 如果本节点的索引是0，则合并右侧节点\r\n        if self_index == 0:\r\n            marge_index = self_index + 1\r\n        # 如果本节点左侧节点没有元素可借，右侧有节点且有元素可借，则借右侧节点的元素\r\n        elif len(parent.next) > self_index + 1 and len(parent.next[self_index - 1].keys) <= BPlusTree.min_keys < len(\r\n                parent.next[self_index + 1].keys):\r\n            marge_index = self_index + 1\r\n        # 其他情况合并左侧节点或向左侧节点借元素\r\n        else:\r\n            # print(\"left node\")\r\n            marge_index = self_index - 1\r\n        return marge_index\r\n\r\n    \"\"\"如果借了一个元素返回None，如果合并了一个节点返回父节点要删除的元素\"\"\"\r\n\r\n    def merge_leaves(self, parent, index):\r\n        if parent is None:\r\n            return None\r\n        # 本节点在父节点的索引\r\n        self_index = parent.next.index(self)\r\n        marge_index = self.find_merge_index(parent)\r\n        marge_node = parent.next[marge_index]\r\n        # print(f\"marge_node.keys:{marge_node.keys}\")\r\n        # 如果有元素可借\r\n        if len(marge_node.keys) > BPlusTree.min_keys:\r\n            # print(\"borrow\")\r\n            # 如果要向右侧的节点借元素，因为借的是第一个元素，所以要将其在父节点上的索引改为其原来的第二个元素（新的第一个元素）\r\n            if self_index < marge_index:\r\n                self.keys.append(marge_node.keys[0])\r\n                parent_change = parent.keys.index(self.keys[0])\r\n                del self.keys[index]\r\n                del self.values[index]\r\n                marge_node.keys.pop(0)\r\n                parent.keys[parent_change] = marge_node.keys[0]\r\n                self.values.append(marge_node.values[0])\r\n                marge_node.values.pop(0)\r\n            # 如果要向左侧的节点借元素，因为改变了本节点的第一个元素，所以要将在父节点上的索引改为原来的左侧节点的末尾元素（新的第一个元素）\r\n            else:\r\n                # print(parent.keys)\r\n                parent_change = parent.keys.index(self.keys[0])\r\n                del self.keys[index]\r\n                del self.values[index]\r\n                self.keys.insert(0, marge_node.keys[-1])\r\n                parent.keys[parent_change] = self.keys[0]\r\n                marge_node.keys.pop()\r\n                self.values.insert(0, marge_node.values[-1])\r\n                marge_node.values.pop()\r\n            # 因为已经修改了父节点上的索引，所以不需要再返回要向上修改的值\r\n            return None\r\n        # 如果没有元素可借，合并节点，并返回父节点中要删除的索引\r\n        else:\r\n            # 合并节点\r\n            if self_index < marge_index:\r\n                # print(f\"{self_index} < {marge_index}\")\r\n                delete_key = marge_node.keys[0]\r\n                self.keys.extend(marge_node.keys)\r\n                self.values.extend(marge_node.values)\r\n                self.next = marge_node.next\r\n                parent.next.pop(marge_index)\r\n                return delete_key\r\n            else:\r\n                delete_key = parent.keys[marge_index]\r\n                # print(f\"delete_key:{delete_key}\")\r\n                self.keys = marge_node.keys + self.keys\r\n                self.values = marge_node.values + self.values\r\n                parent.next.pop(marge_index)\r\n                # print(self.keys)\r\n                return delete_key\r\n\r\n    def merge(self, parent):\r\n        if parent is None:\r\n            return None\r\n        # 本节点在父节点的索引\r\n        # print(f\"parent.keys:{parent.keys},len(parent.next):{len(parent.next)}\")\r\n        self_index = parent.next.index(self)\r\n        marge_index = self.find_merge_index(parent)\r\n        marge_node = parent.next[marge_index]\r\n        # 如果有元素可借\r\n        # print(marge_node.keys)\r\n        # print(f\"len(marge_node.keys):{len(marge_node.keys)}\")\r\n        if len(marge_node.keys) > BPlusTree.min_keys:\r\n            if self_index < marge_index:\r\n                # print(self.keys)\r\n                self.keys.append(parent.keys[self_index])\r\n                parent.keys[self_index] = marge_node.keys[0]\r\n                marge_node.keys.pop(0)\r\n                self.next.append(marge_node.next[0])\r\n                marge_node.next.pop(0)\r\n            else:\r\n                self.keys.insert(0, parent.keys[self_index - 1])\r\n                parent.keys[self_index - 1] = marge_node.keys[-1]\r\n                marge_node.keys.pop()\r\n                self.next.insert(0, marge_node.next[-1])\r\n                marge_node.next.pop()\r\n            return None\r\n        # 如果没有元素可借，从父节点取一个索引，再合并节点，返回父节点中要删除的索引\r\n        else:\r\n            # 如果要合并的节点在右侧，则新的索引要添加从父节点取的索引再加上要合并节点的索引\r\n            if self_index < marge_index:\r\n                self.keys = self.keys + [parent.keys[self_index]] + marge_node.keys\r\n                # self.keys.extend(parent.keys[self_index])\r\n                # self.keys.extend(marge_node.keys)\r\n                self.next.extend(marge_node.next)\r\n                parent.next.pop(marge_index)\r\n                # print(self.keys)\r\n                # print(parent.keys[self_index])\r\n                return parent.keys[self_index]\r\n            # 如果要合并的节点在左侧，则新的索引要在前面加上要合并节点的索引和从父节点取的索引\r\n            else:\r\n                # print(\"borrow\")\r\n                self.keys.insert(0, parent.keys[marge_index])\r\n                self.keys = marge_node.keys + self.keys\r\n                self.next = marge_node.next + self.next\r\n                parent.next.pop(marge_index)\r\n                return parent.keys[marge_index]\r\n\r\n    def remove(self, key, parent):\r\n        if self.is_leaf is False:\r\n            # print(f\"key:{key}    next_index:{self.find_next_index(key)}\")\r\n            # 如果不是叶子节点则递归深入\r\n            # print(f\"go:{self.keys}\")\r\n            delete_key = self.next[self.find_next_index(key)].remove(key, self)\r\n        else:\r\n            # 如果是叶子节点，则判断要删除的值是否存在\r\n            # print(f\"go:{self.keys}\")\r\n            index = self.find_index(key)\r\n            # print(f\"index:{index}\")\r\n            # 如果不存在返回None\r\n            if index is None:\r\n                return None\r\n            else:\r\n                # 如果存在删除keys和value\r\n\r\n                # print(self.keys)\r\n                if len(self.keys) < BPlusTree.min_keys + 1:\r\n                    return self.merge_leaves(parent, index)\r\n                else:\r\n                    return None\r\n        # 如果不是叶子节点，且子节点返回了一个要删除的索引，则删除索引\r\n        # print(f\"delete_key:{delete_key}\")\r\n        if delete_key is not None:\r\n            index = self.find_index(delete_key)\r\n            self.keys.pop(index)\r\n        if len(self.keys) < BPlusTree.min_keys:\r\n            return self.merge(parent)\r\n        else:\r\n            return None\r\n\r\n\r\nclass BPlusTree:\r\n    max_keys = 4\r\n    min_keys = 2\r\n\r\n    def __init__(self):\r\n        self.root = BPlusNode(is_leaf=True)\r\n\r\n    # 查询，从根节点开始查询\r\n    def find(self, name):\r\n        return self.root.find_value(name)\r\n\r\n    # 插入\r\n    \"\"\"如果根节点需要发生裂变，则产生一个新的头节点，它的两个next分别指向原根节点和新节点\"\"\"\r\n\r\n    def insert(self, value):\r\n        global carry\r\n        new_node = self.root.insert(value.name, value)\r\n        # print(f\"{course1.id}\")\r\n        # 如果根节点也要发生裂变则要创建新的根节点\r\n        if new_node is not None:\r\n            # print(f\"new_node.keys:{new_node.keys}\")\r\n            new_root = BPlusNode()\r\n            new_root.keys.insert(0, carry)\r\n            new_root.next = [self.root, new_node]\r\n            self.root = new_root\r\n            # print(type(self.root.next))\r\n        # print(f\"{course1.id}\")\r\n\r\n    def remove(self, name):\r\n        # print(f\"root:{self.root.keys}\")\r\n        self.root.remove(name, None)\r\n        # 当头节点的索引被全部删除时，它唯一的孩子就是新的头节点\r\n        if len(self.root.keys) == 0:\r\n            self.root = self.root.next[0]\r\n\r\n    \"\"\"修改成功返回Ture，失败返回False\"\"\"\r\n\r\n    def revise(self, old_value, new_value):\r\n        if self.find(old_value.name) is not None:\r\n            # 先插入新值，再删除旧值\r\n            self.insert(new_value)\r\n            self.remove(old_value.name)\r\n            return True\r\n        else:\r\n            return False\r\n\r\n    \"\"\"获取全部数据\"\"\"\r\n\r\n    def get_all_data(self):\r\n        # print(\"get\")\r\n        node = self.root\r\n        # 从根节点下探到最左侧的叶子节点\r\n        while node.is_leaf is False:\r\n            node = node.next[0]\r\n        # print(node.keys)\r\n        all_data = node.values\r\n        # 依次获取全部节点的数据\r\n        while len(node.next) != 0:\r\n            # print(node.next[0].keys)\r\n            all_data.extend(node.next[0].values)\r\n            node = node.next[0]\r\n        return all_data\r\n\r\n    def prefix_search(self, name):\r\n        return self.root.find_prefix_value(name)\r\n\r\n\r\nclass Usr:\r\n    name: string\r\n    id: int\r\n    email: string\r\n    userNumber: string\r\n\r\n    def __init__(self, username, email, userNumber):\r\n        self.name = username\r\n        self.email = email\r\n        self.userNumber = userNumber\r\n\r\n\r\nclass Teacher(Usr):\r\n    user_table: MyHash\r\n    course_tree: BPlusTree\r\n    course_table: MyHash\r\n\r\n    def __init__(self, name, password, academy, course_tree, course_table, user_table):\r\n        super().__init__(name, password, academy)\r\n        self.course_table = course_table\r\n        self.course_tree = course_tree\r\n        self.is_student = False\r\n        self.user_table = user_table\r\n\r\n    def insert(self, course):\r\n        self.course_tree.insert(course)\r\n        self.course_table.insert(course)\r\n        for st in course.student:\r\n            self.user_table.find(st).course.append(course)\r\n\r\n    def remove(self, course):\r\n        self.course_tree.remove(course.name)\r\n        self.course_table.remove(course.id)\r\n\r\n    def revise(self, old_course, new_course):\r\n        self.course_tree.revise(old_course, new_course)\r\n        self.course_table.revise(old_course, new_course)\r\n\r\n    # 通过名称查找\r\n    def find_by_name(self, name):\r\n        return self.course_tree.find(name)\r\n\r\n    # 通过名称的前缀查找\r\n    def prefix_search(self, name):\r\n        return self.course_tree.prefix_search(name)\r\n\r\n    # 通过id查找\r\n    def find_by_id(self, hash_id):\r\n        return self.course_table.find(hash_id)\r\n\r\n\r\nclass Student(Usr):\r\n    course: list  # 每个学生自己的课程\r\n    student_class: int\r\n    majors: string\r\n\r\n    def __init__(self, username, email, userNumber):\r\n        super().__init__(username, email, userNumber)\r\n        self.course=[]\r\n\r\n    \"\"\"def __init__(self, name, password, academy, student_class, majors):\r\n        super().__init__(username, email, userNumber)\r\n        self.student_class = student_class\r\n        self.majors = majors\r\n        self.course = []\r\n        self.is_student = True\"\"\"\r\n\r\n    def sort_by_time(self):\r\n        course_list = []\r\n        dic = {}\r\n        for cour in self.course:\r\n            dic[cour.begintime + cour.day * 100] = cour\r\n        for key in sorted(dic):\r\n            course_list.append(dic[key])\r\n        return course_list\r\n\r\n    def sort_by_name(self):\r\n        course_list = []\r\n        dic = {}\r\n        for cour in self.course:\r\n            dic[cour.name] = cour\r\n        for key in sorted(dic):\r\n            course_list.append(dic[key])\r\n        return course_list\r\n\r\n    def sort_by_id(self):\r\n        course_list = []\r\n        dic = {}\r\n        for cour in self.course:\r\n            dic[cour.id] = cour\r\n        for key in sorted(dic):\r\n            course_list.append(dic[key])\r\n        return course_list\r\n\r\n\r\nclass UserManagement:\r\n    user_table: MyHash\r\n\r\n    def __init__(self, user_table):\r\n        self.user_table = user_table\r\n\r\n    def user_init(self, username, email, userNumber):\r\n        user = Student(username, email, userNumber)\r\n        self.user_table.insert(user)\r\n        print(user.id)\r\n\r\n    # 登陆成功返回用户，不成功返回None\r\n    def login(self, user_id):\r\n        user = self.user_table.find(user_id)\r\n        return user\r\n\r\n    def all_student(self):\r\n            return self.user_table.my_hash_table\r\n\r\n\r\n# # 先把课程的B+树、哈希，和学生的哈希读出来\r\n# course_tree = BPlusTree()\r\n# course_table = MyHash()\r\n# user_table = MyHash()\r\n# # 实例化用户管理对象\r\n# user_management = UserManagement(user_table)\r\n# # 注册\r\n# # user_management.sign_up_teacher(\"teacher\", \"000\", \"1\", course_tree, course_table)\r\n# # user_management.sign_up_student(\"student1\", \"111\", '1', \"1\", \"0\")\r\n# # 登录\r\n# teacher = user_management.login(0, \"000\")\r\n# student = user_management.login(1, \"111\")\r\n# # 面向用户操作\r\n# teacher.insert(Course(\"computer\", [1]))\r\n# print(student.sort_by_name()[0].name)\r\n\r\n\"\"\"c = []\r\nfor i in range(0, 2000):\r\n    c.insert(i, Course(\"str:\" + str(i)))\r\ncourse_tree = BPlusTree()\r\nmy_hash = MyHash()\r\n# a = Course(1)\r\n# print(tree.find(key=200))\r\n\r\nfor i in range(0, 500):\r\n    course_tree.insert(c[i])\r\n    # my_hash.insert(c[i])\r\n    # print(i)\r\nfor i in range(500, 1001):\r\n    course_tree.insert(c[i])\r\n    # my_hash.insert(c[i])\r\nfor i in range(1500, 1000, -1):\r\n    course_tree.insert(c[i])\r\n    # my_hash.insert(c[i])\r\nfor i in range(0, 100):\r\n    # print(f\"remove{i}\")\r\n    course_tree.remove(\"str:\" + str(i))\r\nfor i in range(1000, 1400):\r\n    # print(f\"remove{i}\")\r\n    course_tree.remove(\"str:\" + str(i))\r\ncourse_tree.insert(c[1100])\r\ncourse_tree.revise(c[1100], c[1101])\r\nfor i in range(100, 500):\r\n    print(course_tree.find(name=\"str:\" + str(i)).name)\r\nprint(course_tree.find(name=\"str:\" + str(1)).name)\r\nfor i in course_tree.prefix_search(name=\"str:\" + str(10)):\r\n    print(i.name)  # 打印查找结果，如果查找成功则打印id,未作非法检验\r\ncourse_tree.get_all_data()\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/course.py b/app/course.py
--- a/app/course.py	
+++ b/app/course.py	
@@ -57,6 +57,7 @@
 
     def find(self, hash_id):
         if hash_id < len(self.my_hash_table):
+            print(self.empty)
             return self.my_hash_table[hash_id]
         else:
             return None
@@ -369,6 +370,8 @@
                 if len(self.keys) < BPlusTree.min_keys + 1:
                     return self.merge_leaves(parent, index)
                 else:
+                    del self.keys[index]
+                    del self.values[index]
                     return None
         # 如果不是叶子节点，且子节点返回了一个要删除的索引，则删除索引
         # print(f"delete_key:{delete_key}")
